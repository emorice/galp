"""
Implementation of the lower level of GALP, handles routing.
"""

from dataclasses import dataclass
from typing import TypeAlias, Callable, Iterable, Generic, TypeVar

import logging

from galp.writer import TransportMessage, Writer

# Routing-layer data structures
# =============================

Route = list[bytes]
"""
This actually ZMQ specific and should be changed to a generic if we ever need
more protocols
"""

@dataclass
class Routes:
    """
    The routing layer of a message
    """
    incoming: Route
    forward: Route

# Routing-layer writers
# =====================

@dataclass
class LowerSession:
    """
    Keeps track of routing information of a peer and origin to address messages

    This should be internal, since it's modular session and not type safe.
    """
    write_lower: Writer
    is_router: bool
    routes: Routes

    def write(self, payload: list[bytes]) -> list[bytes]:
        """
        Adds this layer and the ones below's information to the payload generated by the upper
        layer.
        """
        return self.write_lower(self.write_message() + payload)

    def write_message(self) -> list[bytes]:
        """
        Dumps route as frames
        """
        if self.is_router:
            # If routing, we need an id, we take it from the forward segment
            # Note: this id is consumed by the zmq router sending stage and does
            # not end up on the wire
            next_hop, *forward_route = self.routes.forward
            return [next_hop, *self.routes.incoming, *forward_route, b'']
        return [*self.routes.incoming, *self.routes.forward, b'']

UpperSessionT = TypeVar('UpperSessionT')
"""
Generic type of the session of the layer above. The actual type gets injected,
and this is then the type the users sees. This way the layers stays decoupled,
but it is still impossible for the user to mix layers improperly.
"""

@dataclass
class GenReplyFromSession(Generic[UpperSessionT]):
    """
    Session encapsulating a destination but letting the user fill in the origin
    part of the message

    This is what is exposed to the user, and must be type safe.
    """
    write_lower: Writer
    is_router: bool
    forward: Route
    make_upper: Callable[[LowerSession], UpperSessionT]

    def reply_from(self, origin: 'GenReplyFromSession | None') -> UpperSessionT:
        """
        Creates a session to send galp messages

        Args:
            origin: where the message originates from and where replies should
            be sent. If None, means the message was locally generated.
        """
        nat_origin = Route() if origin is None else origin.forward
        return self.make_upper(
                LowerSession(self.write_lower, self.is_router,
                    Routes(incoming=nat_origin, forward=self.forward)
                )
                )

    @property
    def uid(self):
        """
        Hashable identifier for this destination
        """
        return tuple(self.forward)

@dataclass
class GenForwardSessions(Generic[UpperSessionT]):
    """
    Pair of sessions exposed to app on forward.

    The two sessions represent the sender of the message, and its recipient
    """
    origin: GenReplyFromSession[UpperSessionT]
    dest: GenReplyFromSession[UpperSessionT]

def make_local_session(is_router: bool) -> LowerSession:
    """
    Create a default-addressing session
    """
    return LowerSession(lambda msg: msg, is_router, Routes(incoming=Route(), forward=Route()))

# Routing-layer handlers
# ======================

TransportHandler: TypeAlias = Callable[
        [Writer, list[bytes]], Iterable[TransportMessage]
        ]
"""
Type of handler implemented by this layer and intended to be passed to the
transport
"""

AppSessionT = TypeVar('AppSessionT')
"""
Generic type of the session, or collection thereof, passed to the final app
handler. In practice this type is almost always known, but a few bits of code
benefit from treating it as a generic.
"""

GenRoutedHandler: TypeAlias = Callable[
        [
            # Session used by upper parser to send back parsing error messages
            GenReplyFromSession[UpperSessionT],
            # Session used by app handler to send other responses or forward
            AppSessionT, #GenReplyFromSession[UpperSessionT],
            # Payload
            list[bytes]
            ],
        # Messages to be sent in reaction
        Iterable[TransportMessage]]
"""
Type of the next-layer ("routed" layer, once the "routing" is parsed) handler to
be injected. This is generic in the upper session type (that is, the kind of
messages that can be sent) and the type of session passed to the app handler.
"""

GenLocalHandler: TypeAlias = GenRoutedHandler[UpperSessionT,
        GenReplyFromSession[UpperSessionT]]
"""
More specific type of next-layer handler for the local case.
"""

GenForwardHandler: TypeAlias = GenRoutedHandler[UpperSessionT,
        GenForwardSessions[UpperSessionT]]
"""
More specific type of next-layer handler for the forward case.
"""

class IllegalRequestError(Exception):
    """Base class for all badly formed requests, should trigger sending an ILLEGAL
    message back"""
    def __init__(self, reason: str):
        super().__init__()
        self.reason = reason

def _handle_illegal(upper: TransportHandler) -> TransportHandler:
    """
    Wraps a handler to catch IllegalRequestError, log, then suppress them.

    At this level, we don't send error messages back.
    """
    def on_message(session: Writer, msg: list[bytes]
            ) -> Iterable[TransportMessage]:
        try:
            return upper(session, msg)
        except IllegalRequestError as exc:
            logging.warning('Supressing malformed incoming message: %s', exc.reason)
            return []
    return on_message

def _parse_lower(msg: list[bytes]) -> tuple[list[bytes], tuple[Route, Route]]:
    """
    Parses and returns the routing part of `msg`, and body.

    Can be overloaded to handle different routing strategies.
    """
    route_parts = []
    while msg and msg[0]:
        route_parts.append(msg[0])
        msg = msg[1:]
    # Whatever was found is treated as the route. If it's malformed, we
    # cannot know, and we cannot send answers anywhere else.
    route = route_parts[:1], route_parts[1:]

    # Discard empty frame
    if not msg or  msg[0]:
        raise IllegalRequestError('Missing empty delimiter frame')
    msg = msg[1:]

    return msg, route

def _handle_routing(router: bool, upper: GenLocalHandler[UpperSessionT],
            upper_forward: GenForwardHandler[UpperSessionT] | None,
            make_upper_session: Callable[[LowerSession], UpperSessionT]) -> TransportHandler:
    """
    Parses the routing part of a GALP message,
    then calls the upper protocol with the parsed message.

    This creates two sessions: one associated with the original recipient
    (forward session), and one associated with the original sender (reply
    session). Generating the outgoing forwarded message is up to the forward
    handler.

    Args:
        router: True if sending function should move a routing id in the
            first routing segment. Default False.
    """
    def on_message(session: Writer, msg_parts: list[bytes]
                   ) -> Iterable[list[bytes]]:
        payload, routes = _parse_lower(msg_parts)

        incoming_route, forward_route = routes
        is_forward = bool(forward_route)

        reply = GenReplyFromSession(session, router, incoming_route, make_upper_session)
        forward = GenReplyFromSession(session, router, forward_route, make_upper_session)
        both = GenForwardSessions(origin=reply, dest=forward)

        if is_forward:
            if upper_forward:
                return upper_forward(reply, both, payload)
            return []

        return upper(reply, reply, payload)
    return on_message

def handle_routing(router: bool,
        upper_local: GenLocalHandler,
        upper_forward: GenForwardHandler | None,
        make_upper_session: Callable[[LowerSession], UpperSessionT]
        ) -> TransportHandler:
    """
    Stack the routing-layer handlers
    """
    return _handle_illegal(
            _handle_routing(router,
                upper_local, upper_forward,
                make_upper_session
                )
            )
