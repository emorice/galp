"""
Implementation of the lower level of GALP, handles routing.
"""

from dataclasses import dataclass
from typing import TypeAlias, Callable, Iterable, Generic, TypeVar

import logging

# Routing-layer data structures
# =============================

Route = list[bytes]
"""
This actually ZMQ specific and should be changed to a generic if we ever need
more protocols
"""

@dataclass
class Routes:
    """
    The routing layer of a message
    """
    incoming: Route
    forward: Route

# Routing-layer writers
# =====================

TransportMessage: TypeAlias = list[bytes]
"""
Type of messages expected by the transport, also somewhat ZMQ-specific
"""

@dataclass
class Session:
    """
    Object encapsulating information received in previous messages along with
    the callbacks necessary to generate new messages from this information.

    Typically, this is is used to implement request-reply patterns,
    authentication, or any scheme when a peer has to remember some information
    from the last received message to generate the next one.
    """
    lower_session: 'Session | None'

    def write_message(self) -> list[bytes]:
        """
        Serializes this layer's session's message
        """
        return []

    def write_layer(self, payload: list[bytes]) -> list[bytes]:
        """
        Adds this layer's information to the payload generated by the upper
        layer. Default is to pass the payload unmodified.
        """
        return self.write_message() + payload

    def write(self, payload: list[bytes]) -> list[bytes]:
        """
        Adds this layer and the ones below's information to the payload generated by the upper
        layer.
        """
        current = self.write_layer(payload)
        if self.lower_session:
            return self.lower_session.write(current)
        return current

@dataclass
class LowerSession(Session):
    """
    Keeps track of routing information of a peer and origin to address messages

    This should be internal, since it's modular session and not type safe.
    """
    is_router: bool
    routes: Routes

    def write_message(self) -> list[bytes]:
        """
        Dumps route as frames
        """
        if self.is_router:
            # If routing, we need an id, we take it from the forward segment
            # Note: this id is consumed by the zmq router sending stage and does
            # not end up on the wire
            next_hop, *forward_route = self.routes.forward
            return [next_hop, *self.routes.incoming, *forward_route, b'']
        return [*self.routes.incoming, *self.routes.forward, b'']

UpperSessionT = TypeVar('UpperSessionT')
"""
Generic type of the session of the layer above. The actual type gets injected,
and this is then the type the users sees. This way the layers stays decoupled,
but it is still impossible for the user to mix layers improperly.
"""

@dataclass
class GenReplyFromSession(Generic[UpperSessionT]):
    """
    Session encapsulating a destination but letting the user fill in the origin
    part of the message

    This is what is exposed to the user, and must be type safe.
    """
    lower: Session
    is_router: bool
    forward: Route
    make_upper: Callable[[LowerSession], UpperSessionT]

    def reply_from(self, origin: 'GenReplyFromSession | None') -> UpperSessionT:
        """
        Creates a session to send galp messages

        Args:
            origin: where the message originates from and where replies should
            be sent. If None, means the message was locally generated.
        """
        nat_origin = Route() if origin is None else origin.forward
        return self.make_upper(
                LowerSession(self.lower, self.is_router,
                    Routes(incoming=nat_origin, forward=self.forward)
                )
                )

    @property
    def uid(self):
        """
        Hashable identifier for this destination
        """
        return tuple(self.forward)

def make_local_session(is_router: bool) -> LowerSession:
    """
    Create a default-addressing session
    """
    return LowerSession(None, is_router, Routes(incoming=Route(), forward=Route()))

# Routing-layer handlers
# ======================

TransportHandler: TypeAlias = Callable[
        [Session, list[bytes]], Iterable[TransportMessage]
        ]
"""
Type of handler implemented by this layer and intended to be passed to the
transport
"""

GenRoutedHandler: TypeAlias = Callable[
        [GenReplyFromSession[UpperSessionT], list[bytes]], Iterable[TransportMessage]
        ]
"""
Type of the next-layer ("routed" layer, once the "routing" is parsed) handler to
be injected.
"""

class IllegalRequestError(Exception):
    """Base class for all badly formed requests, should trigger sending an ILLEGAL
    message back"""
    def __init__(self, reason: str):
        super().__init__()
        self.reason = reason

def _handle_illegal(upper: TransportHandler) -> TransportHandler:
    """
    Wraps a handler to catch IllegalRequestError, log, then suppress them.

    At this level, we don't send error messages back.
    """
    def on_message(session: Session, msg: list[bytes]
            ) -> Iterable[TransportMessage]:
        try:
            return upper(session, msg)
        except IllegalRequestError as exc:
            logging.warning('Supressing malformed incoming message: %s', exc.reason)
            return []
    return on_message

def _parse_lower(msg: list[bytes]) -> tuple[list[bytes], tuple[Route, Route]]:
    """
    Parses and returns the routing part of `msg`, and body.

    Can be overloaded to handle different routing strategies.
    """
    route_parts = []
    while msg and msg[0]:
        route_parts.append(msg[0])
        msg = msg[1:]
    # Whatever was found is treated as the route. If it's malformed, we
    # cannot know, and we cannot send answers anywhere else.
    route = route_parts[:1], route_parts[1:]

    # Discard empty frame
    if not msg or  msg[0]:
        raise IllegalRequestError('Missing empty delimiter frame')
    msg = msg[1:]

    return msg, route

def _handle_routing(router: bool, upper: GenRoutedHandler,
            upper_forward: GenRoutedHandler | None,
            make_upper_session: Callable[[LowerSession], UpperSessionT]) -> TransportHandler:
    """
    Parses the routing part of a GALP message,
    then calls the upper protocol with the parsed message.

    This creates two sessions: one associated with the original recipient
    (forward session), and one associated with the original sender (reply
    session). By default, the forward session is used immediately to forward
    the incoming message, and only the reply session is exposed to the layer
    above. Messages are automatically forwarded without further action from
    the higher handlers ; however, interrupting the handler with, say, a
    validation error would cause the forwarded message to be dropped too.

    Args:
        router: True if sending function should move a routing id in the
            first routing segment. Default False.
    """
    def on_message(session: Session, msg_parts: list[bytes]
                   ) -> Iterable[list[bytes]]:
        payload, routes = _parse_lower(msg_parts)

        incoming_route, forward_route = routes
        is_forward = bool(forward_route)

        forward = LowerSession(session, router,
                               Routes(incoming_route, forward_route)
                               )
        reply = GenReplyFromSession(session, router, incoming_route, make_upper_session)
        out = []

        if is_forward:
            out.append(forward.write(payload))
            if upper_forward:
                out.extend(upper_forward(reply, payload))
            return out

        return upper(reply, payload)
    return on_message

def handle_routing(router: bool,
        upper_local: GenRoutedHandler,
        upper_forward: GenRoutedHandler | None,
        make_upper_session: Callable[[LowerSession], UpperSessionT]
        ) -> TransportHandler:
    """
    Stack the routing-layer handlers
    """
    return _handle_illegal(
            _handle_routing(router,
                upper_local, upper_forward,
                make_upper_session
                )
            )
