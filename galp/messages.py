"""
Models for Galp messages

Not in actual use yet
"""

from typing import Literal, Annotated, TypeAlias
from dataclasses import field, dataclass
from pydantic import Field

from . import task_types as gtt
from .task_types import TaskName, TaskDef, CoreTaskDef, TaskRef

# Replies
# ========

@dataclass(frozen=True)
class Doing:
    """
    A message signaling that a task has been allocated or started

    Attributes:
        name: the task name
    """
    name: TaskName

    verb: Literal['doing'] = field(default='doing', repr=False)

@dataclass(frozen=True)
class Done:
    """
    A message signaling that a task has been succesful run

    Attributes:
        task_def: the task
        children: the child tasks, typically not yet run, generated by the task
            execution
    """
    task_def: TaskDef
    result: gtt.FlatResultRef

    verb: Literal['done'] = field(default='done', repr=False)

    @property
    def name(self) -> TaskName:
        """
        Task name
        """
        return self.task_def.name

@dataclass(frozen=True)
class Failed:
    """
    Signals that the execution of task has failed

    Attributes:
        task_def: the definition of the failed task
    """
    task_def: CoreTaskDef

    verb: Literal['failed'] = field(default='failed', repr=False)

    @property
    def name(self) -> TaskName:
        """
        Task name
        """
        return self.task_def.name

@dataclass(frozen=True)
class Found:
    """
    A message notifying that a task was registered, but not yet executed

    Attributes:
        task_def: the task definition
    """
    task_def: TaskDef

    verb: Literal['found'] = field(default='found', repr=False)

    @property
    def name(self) -> TaskName:
        """
        Task name
        """
        return self.task_def.name

@dataclass(frozen=True)
class NotFound:
    """
    A message indicating that no trace of a task was found

    Attributes:
        name: the task name
    """
    name: TaskName

    verb: Literal['not_found'] = field(default='not_found', repr=False)

@dataclass(frozen=True)
class Put:
    """
    A message sending a serialized task result

    Atrributes:
        name: the task name whose result is sent
        data: the serialized result data
        children: the subordinate task references that are linked from within the
            serialized data
    """
    name: TaskName
    data: bytes
    children: list[TaskRef]

    verb: Literal['put'] = field(default='put', repr=False)

ReplyValue = Annotated[
        Done | Failed | Found | NotFound | Put | Doing,
        Field(discriminator='verb')
        ]

# Messages
# ========

class MessageRegistry:
    """
    Associate message classes with unique keys that can be used to mux and
    demux them when serializing and deserializing messages
    """
    def __init__(self) -> None:
        self.types: 'dict[bytes, type[Message]]' = {}
        self.keys: 'dict[type[Message], bytes]' = {}

    def register(self, key: str):
        """
        Register a key to indicate a message type when serializing

        While keys are bytes, for convenience this accepts string and
        ascii-encodes them. This always use the lower case string, so that
        registering two messages that differ only by case would also fail.
        """
        b_key = key.lower().encode('ascii')
        def _register(cls: 'type[Message]'):
            if b_key in self.types:
                raise ValueError(f'Message type key {key} is already used for '
                        + str(self.types[b_key]))
            self.types[b_key] = cls
            self.keys[cls] = b_key
            return cls
        return _register

    def get_type(self, key: bytes) -> 'type[Message] | None':
        """
        Returns the type associated with a key
        """
        return self.types.get(key)

    def get_key(self, cls: 'type[Message]') -> bytes:
        """
        Returns the key associated with a type.
        """
        return self.keys[cls]

class Message:
    """
    Base class for messages. Through init_subclass, forces subclasses to
    register a unique key used for communication
    """
    _message_registry = MessageRegistry()

    def __init_subclass__(cls, /, key: str, **kwargs) -> None:
        super().__init_subclass__(**kwargs)
        # Transitional. Since init_subclass is called before the call to
        # dataclass, verb is still a Field object here
        cls._message_registry.register(key)(cls)

    @classmethod
    def message_get_key(cls) -> bytes:
        """
        Get the unique key associated with a class
        """
        return cls._message_registry.get_key(cls)

    @classmethod
    def message_get_type(cls, key: bytes) -> 'type[Message] | None':
        """
        Get the class associated with unique key
        """
        return cls._message_registry.get_type(key)

# Lifecycle
# ----------

@dataclass(frozen=True)
class Exit(Message, key='exit'):
    """
    A message asking a peer to leave the system
    """

@dataclass(frozen=True)
class Exited(Message, key='exited'):
    """
    Signals that a peer (unexpectedly) exited. This is typically sent by an
    other peer that detected the kill event

    Attributes:
        peer: the local id (pid) of the exited peer
    """
    peer: str

@dataclass(frozen=True)
class Illegal(Message, key='illegal'):
    """
    A message notifying that a previously sent message was malformed

    Attributes:
        reason: an error message
    """
    reason:str

@dataclass(frozen=True)
class Fork(Message, key='fork'):
    """
    A message asking for a new peer, compatible with some resource claim, to be
    created.
    """
    mission: bytes
    resources: gtt.ResourceClaim

@dataclass(frozen=True)
class Ready(Message, key='ready'):
    """
    A message advertising a worker joining the system

    Attributes:
        local_id: a string identifying the worker in a local system, typically the pid
        mission: a bytestring identifying why the peer is joining
    """
    local_id: str
    mission: bytes

@dataclass(frozen=True)
class PoolReady(Message, key='poolReady'):
    """
    A message advertising a pool (forkserver) joining the system

    Attributes:
        cpus: list of cpus made available by said pool.
    """
    cpus: list[int]

# Requests
# --------

@dataclass(frozen=True)
class Get(Message, key='get'):
    """
    A message asking for an already computed resource

    Attributes:
        name: the task name
    """
    name: TaskName

    @property
    def task_key(self) -> bytes:
        """
        Unique request identifier
        """
        return f'get:{self.name.hex()}'.encode('ascii')

    verb = 'get'

@dataclass(frozen=True)
class Stat(Message, key='stat'):
    """
    A message asking if a task is defined or executed

    Attributes:
        name: the task name
    """
    name: TaskName

    @property
    def task_key(self) -> bytes:
        """
        Unique request identifier
        """
        return f'stat:{self.name.hex()}'.encode('ascii')

    verb = 'stat'

@dataclass(frozen=True)
class Submit(Message, key='submit'):
    """
    A message asking for a task to be executed

    Attributes:
        task_def: the task to execute
        resources: to be allocated to the task
    """
    task_def: CoreTaskDef
    resources: gtt.ResourceClaim

    @property
    def task_key(self) -> bytes:
        """
        Unique request identifier
        """
        return f'submit:{self.task_def.name.hex()}'.encode('ascii')

    @property
    def name(self) -> TaskName:
        """
        Unify name with get/stat
        """
        return self.task_def.name

    verb = 'submit'

Request: TypeAlias = Get | Stat | Submit

# Req-rep wrappers
# ----------------

@dataclass(frozen=True)
class Exec(Message, key='exec'):
    """
    A message wrapping a Submit with a resource allocation
    """
    submit: Submit
    resources: gtt.Resources

@dataclass(frozen=True)
class Reply(Message, key='reply'):
    """
    Wraps the result to a request, identifing said request
    """
    request: str
    value: ReplyValue
