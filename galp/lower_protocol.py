"""
Implementation of the lower level of GALP, handles routing.
"""

from typing import NoReturn, Iterable

import logging

Route = list[bytes]
"""
This actually ZMQ specific and should be changed to a generic if we ever need
more protocols
"""

PlainMessage = tuple[tuple[Route, Route], list[bytes]]

class IllegalRequestError(Exception):
    """Base class for all badly formed requests, should trigger sending an ILLEGAL
    message back"""
    def __init__(self, route: tuple[Route, Route], reason: str):
        super().__init__()
        self.route = route
        self.reason = reason

class Session:
    """
    Object encapsulating information received in previous messages along with
    the callbacks necessary to generate new messages from this information.

    Typically, this is is used to implement request-reply patterns,
    authentication, or any scheme when a peer has to remember some information
    from the last received message to generate the next one.
    """
    def __init__(self, lower_session: 'Session | None' = None):
        self.lower_session = lower_session

    def write_layer(self, payload: list[bytes]) -> list[bytes]:
        """
        Adds this layer's information to the payload generated by the upper
        layer. Default is to pass the payload unmodified.
        """
        return payload

    def write(self, payload: list[bytes]) -> list[bytes]:
        """
        Adds this layer and the ones below's information to the payload generated by the upper
        layer.
        """
        current = self.write_layer(payload)
        if self.lower_session:
            return self.lower_session.write(current)
        return current

class Layer:
    """
    Base class for protocol layers

    The only effective function is to provide a way to abort handling in
    the message handler to let the invalid handler take the relay.

    The default invalid handler logs the error and suppresses the message
    without attempting to generate any kind of message back.
    """

    def validate(self, condition, route, reason) -> None:
        """
        Calls invalid message callback. Must always raise and be caught if the
        condition fails.
        """
        if not condition:
            raise IllegalRequestError(route, reason)

    def on_message_unsafe(self, session: Session, msg_parts: list[bytes]
            ) -> list[list[bytes]]:
        """
        Public handler for messages, including invalid message handling.
        """
        try:
            return self.on_message(session, msg_parts)
        except IllegalRequestError as exc:
            return self.on_invalid(session, exc)

    def on_message(self, session: Session, msg_parts: list[bytes]
            ) -> list[list[bytes]]:
        """
        Private handler implemtation, rasing on invalid messages
        """
        raise NotImplementedError

    def on_invalid(self, session: Session, exc: IllegalRequestError) -> list[list[bytes]]:
        """
        Handler for invalid messages
        """
        _ = session
        logging.warning('Supressing malformed incoming message: %s', exc.reason)
        return []

class LowerProtocol(Layer):
    """
    Lower half of a galp protocol handler.

    Handles routing and co, exposes only the pre-split message to the upper
    protocol.
    """

    def __init__(self, name, router):
        """
        Args:
            name: short string to include in log messages.
            router: True if sending function should move a routing id in the
                first routing segment. Default False.
        """
        self.proto_name = name
        self.router = router

    # Main public methods
    # ===================

    def on_message(self, session: Session, msg_parts: list[bytes]):
        """
        Parses the lower part of a GALP message,
        then calls the upper protocol with the parsed message.
        """
        msg_body, route = self._parse_lower(msg_parts)

        return self.on_verb(route, msg_body)

    def write_plain_message(self, msg: PlainMessage):
        """
        Concats route and message.
        """
        route, msg_body = msg
        incoming_route, forward_route = route
        if not forward_route:
            # We used to allow these and re-interpret the routes, but that was a
            # hack
            assert not incoming_route, 'Message with an origin but no dest'

        if self.router:
            # If routing, we need an id, we take it from the forward segment
            next_hop, *forward_route = forward_route
            route_parts = [next_hop] + incoming_route + forward_route
        else:
            route_parts = incoming_route + forward_route

        return route_parts + [b''] + msg_body

    # Internal parsing utilities
    # ==========================

    def _parse_lower(self, msg: list[bytes]) -> tuple[list[bytes], tuple[Route, Route]]:
        """
        Parses and returns the routing part of `msg`, and body.

        Can be overloaded to handle different routing strategies.
        """
        route_parts = []
        while msg and msg[0]:
            route_parts.append(msg[0])
            msg = msg[1:]
        # Whatever was found is treated as the route. If it's malformed, we
        # cannot know, and we cannot send answers anywhere else.
        route = route_parts[:1], route_parts[1:]

        # Discard empty frame
        self.validate(msg and not msg[0], route, 'Missing empty delimiter frame')
        msg = msg[1:]

        return msg, route

    def on_verb(self, route: tuple[Route, Route], msg_body: list[bytes]) -> Iterable:
        """
        Higher level interface to implement by subclassing.
        """
        raise NotImplementedError
